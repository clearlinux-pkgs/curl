From 17df65d825401e5fefe75aab70ba8c0aafefa09b Mon Sep 17 00:00:00 2001
From: William Douglas <william.douglas@intel.com>
Date: Wed, 5 Jul 2023 14:12:38 -0700
Subject: [PATCH]  Add pacrunner call for autoproxy resolution

When a http_proxy is not set in the environment, query pacrunner
for the appropriate proxy to use to access the desired URL, if any.

Assumptions of this patch are:
 - Any caching of the proxy script and the resultant URL-specific
  proxy are handled by pacrunner
 - The decision as to when to refresh the proxy script is also made
  by pacrunner

2021-04-01: Rebased for 7.76.0. Adjustments were needed to accommodate
            refactoring in https://github.com/curl/curl/pull/6798.

Signed-off-by: Brad T. Peters <brad.t.peters@intel.com>
Signed-off-by: Arzhan Kinzhalin <arzhan.i.kinzhalin@intel.com>
Signed-off-by: Patrick McCarty <patrick.mccarty@intel.com>
Signed-off-by: William Douglas <william.douglas@intel.com>
---
 lib/url.c | 133 ++++++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 129 insertions(+), 4 deletions(-)

diff --git a/lib/url.c b/lib/url.c
index 0fb6268..7b378d7 100644
--- a/lib/url.c
+++ b/lib/url.c
@@ -59,6 +59,11 @@
 #error "We can't compile without socket() support!"
 #endif
 
+#ifndef CURL_DISABLE_PROXY
+/* Need dbus so we can query pacrunner for proxy */
+#include <dbus/dbus.h>
+#endif /* CURL_DISABLE_PROXY */
+
 #include <limits.h>
 
 #include "doh.h"
@@ -150,6 +155,8 @@ static void data_priority_cleanup(struct Curl_easy *data);
 /* Reject URLs exceeding this length */
 #define MAX_URL_LEN 0xffff
 
+static int query_pacrunner_proxy(char *url, char *host, char *proxy_host);
+
 /*
 * get_protocol_family()
 *
@@ -2035,9 +2042,12 @@ void Curl_free_request_state(struct Curl_easy *data)
 * The returned pointer must be freed by the caller (unless NULL)
 ****************************************************************/
 static char *detect_proxy(struct Curl_easy *data,
-                          struct connectdata *conn)
+                          struct connectdata *conn,
+                          char *url)
 {
   char *proxy = NULL;
+  char proxy_tmp[256];
+  int autoproxy_ret = 0;
 
   /* If proxy was not specified, we check for default proxy environment
    * variables, to enable i.e Lynx compliance:
@@ -2096,7 +2106,17 @@ static char *detect_proxy(struct Curl_easy *data,
   if(prox) {
     proxy = prox; /* use this */
   }
-  else {
+  if(!proxy) {
+    /* No protocol-specific proxy set in the environment.
+     *     Fallback to pacrunner autoproxy lookup */
+    autoproxy_ret = query_pacrunner_proxy(url,
+                        conn->host.name,
+                        proxy_tmp);
+    if (!autoproxy_ret)
+        proxy = strndup(proxy_tmp, 256);
+  }
+
+  if(!proxy) {
     envp = (char *)"all_proxy";
     proxy = curl_getenv(envp); /* default proxy to use */
     if(!proxy) {
@@ -2402,10 +2422,12 @@ static CURLcode create_conn_helper_init_proxy(struct Curl_easy *data,
     Curl_safefree(proxy);
     Curl_safefree(socksproxy);
   }
-#ifndef CURL_DISABLE_HTTP
   else if(!proxy && !socksproxy)
+#ifndef CURL_DISABLE_HTTP
     /* if the host is not in the noproxy list, detect proxy. */
-    proxy = detect_proxy(data, conn);
+    proxy = detect_proxy(data, conn, data->state.url);
+#else  /* !CURL_DISABLE_HTTP */
+    proxy = NULL;
 #endif /* CURL_DISABLE_HTTP */
   if(spacesep)
     infof(data, "space-separated NOPROXY patterns are deprecated");
@@ -3337,6 +3359,109 @@ static void reuse_conn(struct Curl_easy *data,
   conn_free(data, temp);
 }
 
+/**
+ * query_pacrunner_proxy() queries pacrunner via dbus in an
+ * attempt to obtain autoproxy rules. Proxy rules set by the
+ * environment (shell ENV variables) should take precidence over
+ * autproxy, in which case pacrunner is not called.
+ *
+ * Note on error messages: There are none. This is a fall-back attempt
+ * at proxy detection via autoproxy, and any failure is not important.
+ * End result of failure will simply be a direct connection attempt,
+ * which may fail if behind a firewall.
+ *
+ * Return proxy_host: URL for appropriate proxy, if any
+ */
+static int query_pacrunner_proxy(char *url, char *host, char *proxy_host)
+{
+    DBusMessage *msg;
+    DBusMessageIter args;
+    DBusConnection *conn;
+    DBusError dret;
+    DBusPendingCall *pending;
+    int ret = 1;
+    char *prox;
+
+    dbus_error_init(&dret);
+
+    conn = dbus_bus_get(DBUS_BUS_SYSTEM, &dret);
+    if ((dbus_error_is_set(&dret)) || (conn == NULL))
+        return ret;
+
+    msg = dbus_message_new_method_call("org.pacrunner",
+                                        "/org/pacrunner/client",
+                                        "org.pacrunner.Client",
+                                        "FindProxyForURL");
+    if (msg == NULL)
+        goto dbus_fail;
+
+    /* Append dest url args */
+    dbus_message_iter_init_append(msg, &args);
+    ret = dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &url);
+    if (!ret) {
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    ret = dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &host);
+    if (!ret) {
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    /* Send msg and get handle for reply */
+    ret = dbus_connection_send_with_reply(conn, msg, &pending, -1);
+    if (!ret) {
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    if (pending == NULL) {
+//        printf("curl: Waiting for IO failed with pending == NULL\n");
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    dbus_connection_flush(conn);
+
+    /* Wait for a reply */
+    dbus_pending_call_block(pending);
+
+    /* Get the reply msg */
+    msg = dbus_pending_call_steal_reply(pending);
+    if (msg == NULL) {
+        goto dbus_fail;
+    }
+
+    dbus_pending_call_unref(pending);
+
+    /* Read the parameters */
+    if (!dbus_message_iter_init(msg, &args)) {
+        dbus_message_unref(msg);
+    } else if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING) {
+        dbus_message_unref(msg);
+    } else {
+        /* The arg attached to the response object is a string, which is our expected
+         *  result */
+        dbus_message_iter_get_basic(&args, &prox);
+
+        /* pacrunner prepends all valid proxy URLS with PROXY */
+        if (!strncmp("PROXY", prox, 5)) {
+            if (!dbus_error_is_set(&dret)) {
+                strncpy(proxy_host, prox + 6, 255);
+                ret = 0;
+            }
+        }
+        if (!strncmp("DIRECT", prox, 6))
+                ret = 1;
+    }
+
+dbus_fail:
+    dbus_connection_unref(conn);
+    dbus_error_free(&dret);
+    return ret; /* failure */
+}
+
 /**
  * create_conn() sets up a new connectdata struct, or re-uses an already
  * existing one, and resolves host name.
-- 
2.41.0

