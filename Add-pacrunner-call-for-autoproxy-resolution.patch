From 0325f6b5a63099068310cae6bdc4737f07711a85 Mon Sep 17 00:00:00 2001
From: "Brad T. Peters" <brad.t.peters@intel.com>
Date: Fri, 25 Mar 2016 13:41:56 +0000
Subject: [PATCH] Add pacrunner call for autoproxy resolution

When a http_proxy is not set in the environment, query pacrunner
for the appropriate proxy to use to access the desired URL, if any.

Assumptions of this patch are:
 - Any caching of the proxy script and the resultant URL-specific
  proxy are handled by pacrunner
 - The decision as to when to refresh the proxy script is also made
  by pacrunner

Signed-off-by: Brad T. Peters <brad.t.peters@intel.com>
---

Rebased by Ikey

Signed-off-by: Ikey Doherty <michael.i.doherty@intel.com>
---
 configure.ac    |   2 +
 lib/Makefile.am |   4 +-
 lib/url.c       | 135 +++++++++++++++++++++++++++++++++++++++++++++++++++++---
 3 files changed, 132 insertions(+), 9 deletions(-)

diff --git a/configure.ac b/configure.ac
index b208d4d..786acc4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -41,6 +41,8 @@ AC_CONFIG_MACRO_DIR([m4])
 AM_MAINTAINER_MODE
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 
+PKG_CHECK_MODULES([DBUS], [dbus-1])
+
 CURL_CHECK_OPTION_DEBUG
 CURL_CHECK_OPTION_OPTIMIZE
 CURL_CHECK_OPTION_WARNINGS
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 6f5317a..e1f09c3 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -103,8 +103,8 @@ AM_LDFLAGS =
 AM_CFLAGS =
 
 libcurl_la_CPPFLAGS_EXTRA =
-libcurl_la_LDFLAGS_EXTRA =
-libcurl_la_CFLAGS_EXTRA =
+libcurl_la_LDFLAGS_EXTRA = $(DBUS_LIBS)
+libcurl_la_CFLAGS_EXTRA = $(DBUS_CFLAGS)
 
 if CURL_LT_SHLIB_USE_VERSION_INFO
 libcurl_la_LDFLAGS_EXTRA += $(VERSIONINFO)
diff --git a/lib/url.c b/lib/url.c
index 4044419..1100d5a 100644
--- a/lib/url.c
+++ b/lib/url.c
@@ -78,6 +78,11 @@ void idn_free (void *ptr);
 bool curl_win32_idn_to_ascii(const char *in, char **out);
 #endif  /* USE_LIBIDN */
 
+#ifndef CURL_DISABLE_PROXY
+/* Need dbus so we can query pacrunner for proxy */
+#include <dbus/dbus.h>
+#endif /* CURL_DISABLE_PROXY */
+
 #include "urldata.h"
 #include "netrc.h"
 
@@ -151,6 +156,7 @@ static CURLcode parse_url_login(struct SessionHandle *data,
 static CURLcode parse_login_details(const char *login, const size_t len,
                                     char **userptr, char **passwdptr,
                                     char **optionsptr);
+static int query_pacrunner_proxy(char *url, char *host, char *proxy_host);
 static unsigned int get_protocol_family(unsigned int protocol);
 
 /*
@@ -4533,9 +4539,11 @@ static bool check_noproxy(const char* name, const char* no_proxy)
 * name and is not limited to HTTP proxies only.
 * The returned pointer must be freed by the caller (unless NULL)
 ****************************************************************/
-static char *detect_proxy(struct connectdata *conn)
+static char *detect_proxy(struct connectdata *conn, char *url)
 {
   char *proxy = NULL;
+  char proxy_tmp[256];
+  int autoproxy_ret = 0;
 
 #ifndef CURL_DISABLE_HTTP
   /* If proxy was not specified, we check for default proxy environment
@@ -4598,15 +4606,24 @@ static char *detect_proxy(struct connectdata *conn)
 
     if(prox)
       proxy = prox; /* use this */
-    else {
+
+    if(!proxy) {
+      /* No protocol-specific proxy set in the environment.
+       *     Fallback to pacrunner autoproxy lookup */
+      autoproxy_ret = query_pacrunner_proxy(url,
+                          conn->host.name,
+                          proxy_tmp);
+      if (!autoproxy_ret)
+          proxy = strndup(proxy_tmp, 256);
+    }
+
+    if(!proxy) {
       proxy = curl_getenv("all_proxy"); /* default proxy to use */
       if(!proxy)
         proxy=curl_getenv("ALL_PROXY");
     }
-  } /* if(!check_noproxy(conn->host.name, no_proxy)) - it wasn't specified
-       non-proxy */
+}
   free(no_proxy);
-
 #else /* !CURL_DISABLE_HTTP */
 
   (void)conn;
@@ -5436,12 +5453,115 @@ static void reuse_conn(struct connectdata *old_conn,
 }
 
 /**
+ * query_pacrunner_proxy() queries pacrunner via dbus in an
+ * attempt to obtain autoproxy rules. Proxy rules set by the
+ * environment (shell ENV variables) should take precidence over
+ * autproxy, in which case pacrunner is not called.
+ *
+ * Note on error messages: There are none. This is a fall-back attempt
+ * at proxy detection via autoproxy, and any failure is not important.
+ * End result of failure will simply be a direct connection attempt,
+ * which may fail if behind a firewall.
+ *
+ * Return proxy_host: URL for appropriate proxy, if any
+ */
+static int query_pacrunner_proxy(char *url, char *host, char *proxy_host)
+{
+    DBusMessage *msg;
+    DBusMessageIter args;
+    DBusConnection *conn;
+    DBusError dret;
+    DBusPendingCall *pending;
+    int ret = 1;
+    char *prox;
+
+    dbus_error_init(&dret);
+
+    conn = dbus_bus_get(DBUS_BUS_SYSTEM, &dret);
+    if ((dbus_error_is_set(&dret)) || (conn == NULL))
+        return ret;
+
+    msg = dbus_message_new_method_call("org.pacrunner",
+                                        "/org/pacrunner/client",
+                                        "org.pacrunner.Client",
+                                        "FindProxyForURL");
+    if (msg == NULL)
+        goto dbus_fail;
+
+    /* Append dest url args */
+    dbus_message_iter_init_append(msg, &args);
+    ret = dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &url);
+    if (!ret) {
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    ret = dbus_message_iter_append_basic(&args, DBUS_TYPE_STRING, &host);
+    if (!ret) {
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    /* Send msg and get handle for reply */
+    ret = dbus_connection_send_with_reply(conn, msg, &pending, -1);
+    if (!ret) {
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    if (pending == NULL) {
+//        printf("curl: Waiting for IO failed with pending == NULL\n");
+        dbus_message_unref(msg);
+        goto dbus_fail;
+    }
+
+    dbus_connection_flush(conn);
+
+    /* Wait for a reply */
+    dbus_pending_call_block(pending);
+
+    /* Get the reply msg */
+    msg = dbus_pending_call_steal_reply(pending);
+    if (msg == NULL) {
+        goto dbus_fail;
+    }
+
+    dbus_pending_call_unref(pending);
+
+    /* Read the parameters */
+    if (!dbus_message_iter_init(msg, &args)) {
+        dbus_message_unref(msg);
+    } else if (dbus_message_iter_get_arg_type(&args) != DBUS_TYPE_STRING) {
+        dbus_message_unref(msg);
+    } else {
+        /* The arg attached to the response object is a string, which is our expected
+         *  result */
+        dbus_message_iter_get_basic(&args, &prox);
+
+        /* pacrunner prepends all valid proxy URLS with PROXY */
+        if (!strncmp("PROXY", prox, 5)) {
+            if (!dbus_error_is_set(&dret)) {
+                strncpy(proxy_host, prox + 6, 255);
+                ret = 0;
+            }
+        }
+        if (!strncmp("DIRECT", prox, 6))
+                ret = 1;
+    }
+
+dbus_fail:
+    dbus_connection_unref(conn);
+    dbus_error_free(&dret);
+    return ret; /* failure */
+}
+
+/**
  * create_conn() sets up a new connectdata struct, or re-uses an already
  * existing one, and resolves host name.
  *
  * if this function returns CURLE_OK and *async is set to TRUE, the resolve
  * response will be coming asynchronously. If *async is FALSE, the name is
- * already resolved.
+ * aready resolved.
  *
  * @param data The sessionhandle pointer
  * @param in_connect is set to the next connection data pointer
@@ -5470,6 +5590,7 @@ static CURLcode create_conn(struct SessionHandle *data,
   bool waitpipe = FALSE;
   size_t max_host_connections = Curl_multi_max_host_connections(data->multi);
   size_t max_total_connections = Curl_multi_max_total_connections(data->multi);
+  char prox_tmp[256];
 
   *async = FALSE;
 
@@ -5636,7 +5757,7 @@ static CURLcode create_conn(struct SessionHandle *data,
     proxy = NULL;
   }
   else if(!proxy && !socksproxy)
-    proxy = detect_proxy(conn);
+    proxy = detect_proxy(conn, data->change.url);
 
 #ifdef USE_UNIX_SOCKETS
   if(data->set.str[STRING_UNIX_SOCKET_PATH]) {
-- 
2.7.3

